import re
from typing import Optional, Sequence
from langchain.schema import AIMessage, HumanMessage
from langchain.schema import BaseMessage as AnyMessage
from langchain_core.messages import AIMessage, ToolMessage, HumanMessage

# Helper functions to extract info from messages (Keep as is from original)
def find_last_sql_query(messages: Sequence[AnyMessage]) -> Optional[str]:
    """Finds the last SQL query generated by an AIMessage, handling markdown fences."""
    for msg in reversed(messages):
        if isinstance(msg, AIMessage) and msg.content:
            # Regex to find SQL block, tolerant of optional ```sql marker and leading/trailing whitespace
            match = re.search(r"```(?:sql)?\s*(SELECT.*?)(?:```|$)", msg.content, re.IGNORECASE | re.DOTALL | re.MULTILINE)
            if match:
                return match.group(1).strip()
            # Fallback for plain SQL queries if no markdown fence found
            # Be careful not to match SQL *within* explanations
            # Check if the message *primarily* looks like SQL
            content_stripped = msg.content.strip()
            if content_stripped.upper().startswith(("SELECT ", "WITH ")) and '\n' not in content_stripped[:10]: # Simple heuristic
                 # Avoid matching if it looks like conversational text containing SQL words
                 if len(content_stripped.split()) > 3 and '\n' not in content_stripped: # Likely part of a sentence
                      continue
                 return content_stripped
    print("find_last_sql_query: No SQL query found in recent AIMessages.")
    return None

def find_last_schema(messages: Sequence[AnyMessage], get_schema_tool) -> Optional[str]:
    """Finds the last relevant schema description from Tool or AI messages."""
    schema_content = None
    # Prefer schema from a successful ToolMessage (means tool was actually called)
    for msg in reversed(messages):
        if isinstance(msg, ToolMessage):
             # Check tool name if available, otherwise rely on content marker
             tool_name = getattr(msg, 'name', '')
             is_schema_tool = tool_name == (get_schema_tool.name if get_schema_tool else '')
             # Check content as fallback or primary identifier
             is_schema_content = "create table" in msg.content.lower() and "error" not in msg.content.lower()

             if is_schema_tool and is_schema_content:
                 schema_content = msg.content
                 break
             elif is_schema_content: # If tool name missing but content matches
                 schema_content = msg.content
                 # continue searching in case a named tool message exists earlier

    # If no ToolMessage schema found, check AIMessage content (less reliable)
    if not schema_content:
        for msg in reversed(messages):
             if isinstance(msg, AIMessage) and msg.content and "create table" in msg.content.lower():
                 # Extract potentially relevant part if mixed with explanation? For now, take full content.
                 schema_content = msg.content
                 break # Take the latest one

    if schema_content:
        print(f"find_last_schema: Found schema information. Snippet: {schema_content[:100]}...")
    else:
         print("find_last_schema: No schema information found in messages.")
    return schema_content


def find_question(messages: Sequence[AnyMessage]) -> Optional[str]:
    """Finds the initial HumanMessage question."""
    for msg in messages:
        if isinstance(msg, HumanMessage):
            content = getattr(msg, 'content', None)
            if isinstance(content, str):
                print(f"find_question: Found question: {content[:100]}...")
                return content
            elif isinstance(content, list): # Handle multimodal messages if needed
                 for item in content:
                     if isinstance(item, dict) and item.get("type") == "text":
                         text_content = item.get("text","")
                         print(f"find_question: Found question (from list): {text_content[:100]}...")
                         return text_content
    print("find_question: No HumanMessage question found.")
    return None